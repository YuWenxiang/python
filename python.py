模块 -- 一个个.py文件
	使用模块: import sys
	安装第三方模块： pip install Pillow
	pip： python包管理工具，提供对python包的查找、下载、安装、卸载
	
面向对象编程
	数据封装、继承和多态是面向对象的三大特点
	1。 类和实例
	类是抽象的模板，实例是根据类创建出来的一个个具体的对象
	定义类关键字:class
	创建实例：类名+() eg： bart=Student()
	可以自由的给一个实例变量邦定属性，eg： bart.name="Bob"
	把必须绑定的属性强制写进去用特殊方法__init__, __init__方法的第一个参数必须是self，表示创建实例的本身
	
	数据封装
	在类内部定义访问数据的函数，这些封装数据的函数，我们称之为类的方法
	要定义一个方法，除了第一个参数是self外，其他和普通函数一样
	
	小结
	类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；
	方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；
	通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。
	和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同
	
	2。 访问限制
	如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__；不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量，强烈建议不要这么干
	在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量
	有些时候，会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”
	
	3。 继承和多态
	继承好处:最大的好处是子类获得了父类的全部功能；多态
	多态“开闭原则”：对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。
	静态语言 vs 动态语言：
	对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。
	对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了
	
	小结
	继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。
	动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。
	
	4。 获取对象信息
	判断对象类型： type()  //type(123)
	判断class的类型: isinstance()  //isinstance(d, Dog)
	获得一个对象的所有属性和方法: dir()  //dir('ABC')
	直接操作一个对象的状态:  getattr()、setattr()、hasattr()  //hasattr(obj, 'x') # 有属性'x'吗？
	
	5。 实例属性和类属性
	由于Python是动态语言，根据类创建的实例可以任意绑定属性；给实例绑定属性的方法是通过实例变量，或者通过self变量
	Student类本身需要绑定一个属性，可以直接在class中定义属性，这种属性是类属性，归Student类所有
	/*class Student(object):
		name = 'Student'  */
	del s.name # 如果删除实例的name属性
	
面向对象高级编程
	高级特性包括多重继承、定制类、元类等概念
	1。 使用__slots____
	正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性
	//s.name = 'Michael' # 动态给实例绑定一个属性
	//s.set_age = MethodType(set_age, s) # 给实例绑定一个方法,只是s这个实例可以使用set_age这个方法
	//Student.set_score = set_score//class绑定方法后，所有实例均可调用
	
	限制实例的属性： 特殊的__slots__变量  //只允许对Student实例添加name和age属性  __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
	__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的
	
	2。 使用@property
	@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性
	Python内置的@property装饰器就是负责把一个方法变成属性调用的
	使用: 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值
	
	3. 多重继承
	继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能
	多重继承，一个子类就可以同时获得多个父类的所有功能
	MixIn设计: 在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。
	//class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
	
	小结
	由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。
	只允许单一继承的语言（如Java）不能使用MixIn的设计。
	
	4。定制类
	看到类似__slots__这种形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的
	Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类
	__str__， __repr__ ： __str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串
	__iter__： 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环
	__getitem__： 要表现得像list那样按照下标取出元素，需要实现__getitem__()方法
	__getattr__： 除了__init__可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性
	__call__： 任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。 通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。
	
	5。 枚举类
	Enum类： 枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例
	#from enum import Enum
	#Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
	
	6。 元类
	type()： type()函数可以查看一个类型或变量的类型，type()函数既可以返回一个对象的类型，又可以创建出新的类型
	通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class
	metaclass： 直译为元类， 当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例
	
	
	
	